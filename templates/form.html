{% extends "layout.html" %}

{% block content %}
<div class="max-w-2xl mx-auto bg-white p-8 rounded-lg shadow">
    <h1 class="text-2xl font-bold mb-6 text-gray-900">{% if is_edit %}Edit Recipe{% else %}New Recipe{% endif %}</h1>

    <form action="{% if is_edit %}/recipes/{{ recipe.as_ref().unwrap().id }}{% else %}/recipes{% endif %}" method="post"
        class="space-y-6">
        <div>
            <label for="title" class="block text-sm font-medium text-gray-700">Title</label>
            <input type="text" name="title" id="title" required
                value="{% if is_edit %}{{ recipe.as_ref().unwrap().title }}{% endif %}"
                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2 border">
        </div>

        <div>
            <label for="url" class="block text-sm font-medium text-gray-700">Source URL (Optional)</label>
            <div class="mt-1 flex rounded-md shadow-sm">
                <input type="url" name="url" id="url"
                    value="{% if is_edit %}{% if let Some(url) = recipe.as_ref().unwrap().url %}{{ url }}{% endif %}{% endif %}"
                    class="block w-full rounded-none rounded-l-md border-gray-300 focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2 border">
                <button type="button" id="auto-fill-btn"
                    class="relative -ml-px inline-flex items-center space-x-2 rounded-r-md border border-gray-300 bg-gray-50 px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-100 focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500">
                    <svg class="h-5 w-5 text-gray-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"
                        fill="currentColor">
                        <path fill-rule="evenodd"
                            d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v2H7a1 1 0 100 2h2v2a1 1 0 102 0v-2h2a1 1 0 100-2h-2V7z"
                            clip-rule="evenodd" />
                    </svg>
                    <span>Auto-fill</span>
                </button>
            </div>
            <p id="import-status" class="mt-2 text-sm text-gray-500 hidden"></p>
        </div>

        <div>
            <label for="overview" class="block text-sm font-medium text-gray-700">Overview (Optional)</label>
            <textarea name="overview" id="overview" rows="3"
                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2 border">{% if is_edit %}{% if let Some(overview) = recipe.as_ref().unwrap().overview %}{{ overview }}{% endif %}{% endif %}</textarea>
        </div>

        <div>
            <label class="block text-sm font-medium text-gray-700">Ingredients</label>
            <p class="text-xs text-gray-500 mb-2">Add ingredients with quantity, unit, and name.</p>

            <div id="ingredients-container" class="space-y-2 mb-2">
                <!-- Ingredient rows will be inserted here -->
            </div>

            <button type="button" id="add-ingredient-btn"
                class="inline-flex items-center px-3 py-1.5 border border-gray-300 text-xs font-medium rounded text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                <svg class="h-4 w-4 mr-1 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
                </svg>
                Add Ingredient
            </button>

            <!-- Hidden input to store the actual value sent to server -->
            <input type="hidden" name="ingredients_text" id="ingredients_text"
                value="{% if is_edit %}{% for ingredient in ingredients %}{% if let Some(q) = ingredient.quantity %}{{ q }} {% endif %}{% if let Some(unit) = ingredient.unit %}{{ unit }} {% endif %}{{ ingredient.name }}&#10;{% endfor %}{% endif %}">

            <datalist id="unit-options">
                <option value="cup">
                <option value="cups">
                <option value="tbsp">
                <option value="tsp">
                <option value="oz">
                <option value="lb">
                <option value="g">
                <option value="kg">
                <option value="ml">
                <option value="l">
                <option value="pinch">
                <option value="dash">
                <option value="clove">
                <option value="can">
                <option value="slice">
            </datalist>
        </div>

        <div>
            <label for="instructions" class="block text-sm font-medium text-gray-700">Instructions (Optional)</label>
            <textarea name="instructions" id="instructions" rows="10"
                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2 border">{% if is_edit %}{% if let Some(instr) = recipe.as_ref().unwrap().instructions %}{{ instr }}{% endif %}{% endif %}</textarea>
        </div>

        <div>
            <label class="block text-sm font-medium text-gray-700">Tags</label>
            <p class="text-xs text-gray-500 mb-2">Type and press Enter or Comma to add tags</p>

            <div class="relative">
                <div id="tags-container"
                    class="mt-1 flex flex-wrap gap-2 p-2 border border-gray-300 rounded-md bg-white min-h-[42px] focus-within:ring-1 focus-within:ring-indigo-500 focus-within:border-indigo-500 shadow-sm">
                    <!-- Badges will be inserted here -->
                    <input type="text" id="tag-input"
                        class="flex-grow min-w-[120px] outline-none border-none focus:ring-0 p-0 text-sm"
                        placeholder="Add a tag..." autocomplete="off">
                </div>
                <!-- Dropdown -->
                <div id="tag-dropdown"
                    class="absolute z-10 w-full bg-white shadow-lg max-h-60 rounded-md py-1 text-base ring-1 ring-black ring-opacity-5 overflow-auto focus:outline-none sm:text-sm hidden">
                    <!-- Options will be inserted here -->
                </div>
            </div>

            <!-- Hidden input to store the actual value sent to server -->
            <input type="hidden" name="tags_text" id="tags_text"
                value="{% if is_edit %}{% for tag in tags %}{{ tag.name }}{% if !loop.last %}, {% endif %}{% endfor %}{% endif %}">
        </div>

        <script>
            // Available tags from server, ordered by popularity
            const AVAILABLE_TAGS = [
                {% for tag in all_tags %}"{{ tag }}"{% if !loop.last %}, {% endif %} {% endfor %}
            ];

            document.addEventListener('DOMContentLoaded', () => {
                const container = document.getElementById('tags-container');
                const input = document.getElementById('tag-input');
                const hiddenInput = document.getElementById('tags_text');
                const dropdown = document.getElementById('tag-dropdown');

                // Initialize tags from the server-rendered value
                let tags = hiddenInput.value.split(',')
                    .map(t => t.trim())
                    .filter(t => t.length > 0);

                let selectedIndex = -1;

                function updateHiddenInput() {
                    hiddenInput.value = tags.join(', ');
                }

                function createBadge(text) {
                    const span = document.createElement('span');
                    span.className = 'inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-indigo-100 text-indigo-800';
                    span.innerHTML = `
                        ${text}
                        <button type="button" class="ml-1.5 inline-flex h-4 w-4 flex-shrink-0 items-center justify-center rounded-full text-indigo-400 hover:bg-indigo-200 hover:text-indigo-500 focus:bg-indigo-500 focus:text-white focus:outline-none">
                            <span class="sr-only">Remove large option</span>
                            <svg class="h-2 w-2" stroke="currentColor" fill="none" viewBox="0 0 8 8">
                                <path stroke-linecap="round" stroke-width="1.5" d="M1 1l6 6m0-6L1 7" />
                            </svg>
                        </button>
                    `;

                    // Remove handler
                    span.querySelector('button').addEventListener('click', () => {
                        tags = tags.filter(t => t !== text);
                        updateHiddenInput();
                        span.remove();
                    });

                    return span;
                }

                function renderTags() {
                    // Clear existing badges (keep input)
                    const badges = container.querySelectorAll('span');
                    badges.forEach(b => b.remove());

                    // Add badges before the input
                    tags.forEach(tag => {
                        container.insertBefore(createBadge(tag), input);
                    });
                }

                // Dropdown logic
                function renderDropdown(filterText) {
                    dropdown.innerHTML = '';
                    let matches = [];

                    if (!filterText) {
                        // Top 10 popular tags if input is empty
                        matches = AVAILABLE_TAGS.filter(t => !tags.includes(t)).slice(0, 10);
                    } else {
                        const lowerFilter = filterText.toLowerCase();
                        matches = AVAILABLE_TAGS
                            .filter(t => t.toLowerCase().includes(lowerFilter) && !tags.includes(t))
                            .slice(0, 10); // Limit to top 10 matches
                    }

                    if (matches.length > 0) {
                        matches.forEach((tag, index) => {
                            const div = document.createElement('div');
                            div.className = 'cursor-default select-none relative py-2 pl-3 pr-9 hover:bg-indigo-600 hover:text-white text-gray-900';
                            div.textContent = tag;
                            div.dataset.index = index;

                            div.addEventListener('mousedown', (e) => {
                                e.preventDefault(); // Prevent blur
                                addTag(tag);
                            });

                            dropdown.appendChild(div);
                        });
                        dropdown.classList.remove('hidden');
                        selectedIndex = -1;
                    } else {
                        dropdown.classList.add('hidden');
                    }
                }

                function addTag(tag) {
                    if (tag && !tags.includes(tag)) {
                        tags.push(tag);
                        updateHiddenInput();
                        container.insertBefore(createBadge(tag), input);
                        input.value = '';
                        dropdown.classList.add('hidden');
                        selectedIndex = -1;
                    }
                    input.focus();
                }

                function highlightOption(index) {
                    const options = dropdown.children;
                    for (let i = 0; i < options.length; i++) {
                        if (i === index) {
                            options[i].classList.add('bg-indigo-600', 'text-white');
                            options[i].classList.remove('text-gray-900');
                        } else {
                            options[i].classList.remove('bg-indigo-600', 'text-white');
                            options[i].classList.add('text-gray-900');
                        }
                    }
                }

                // Initial render
                renderTags();

                // Input handling
                input.addEventListener('input', () => {
                    renderDropdown(input.value.trim());
                });

                input.addEventListener('focus', () => {
                    renderDropdown(input.value.trim());
                });

                input.addEventListener('blur', () => {
                    // Delay hiding to allow click event to register
                    setTimeout(() => {
                        dropdown.classList.add('hidden');
                    }, 200);
                });

                input.addEventListener('keydown', (e) => {
                    const options = dropdown.children;

                    if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        if (dropdown.classList.contains('hidden')) {
                            renderDropdown(input.value.trim());
                        } else if (options.length > 0) {
                            selectedIndex = (selectedIndex + 1) % options.length;
                            highlightOption(selectedIndex);
                        }
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        if (dropdown.classList.contains('hidden')) {
                            renderDropdown(input.value.trim());
                        } else if (options.length > 0) {
                            selectedIndex = (selectedIndex - 1 + options.length) % options.length;
                            highlightOption(selectedIndex);
                        }
                    } else if (e.key === 'Enter') {
                        e.preventDefault();
                        if (!dropdown.classList.contains('hidden') && selectedIndex >= 0 && selectedIndex < options.length) {
                            // Select from dropdown
                            addTag(options[selectedIndex].textContent);
                        } else {
                            // Try to add what's typed
                            const val = input.value.trim();
                            if (val) {
                                addTag(val);
                            }
                        }
                    } else if (e.key === ',') {
                        e.preventDefault();
                        const val = input.value.trim();
                        if (val) {
                            addTag(val);
                        }
                    } else if (e.key === 'Backspace' && input.value === '' && tags.length > 0) {
                        // Remove last tag on backspace if input is empty
                        tags.pop();
                        updateHiddenInput();
                        renderTags();
                        dropdown.classList.add('hidden');
                    }
                });

                container.addEventListener('click', () => {
                    input.focus();
                });

                // --- Ingredient Logic ---
                const ingredientsContainer = document.getElementById('ingredients-container');
                const addIngredientBtn = document.getElementById('add-ingredient-btn');
                const ingredientsHiddenInput = document.getElementById('ingredients_text');

                function createIngredientRow(quantity = '', unit = '', name = '') {
                    const row = document.createElement('div');
                    row.className = 'flex gap-2 items-start';
                    row.innerHTML = `
                        <input type="text" placeholder="Qty" value="${quantity}" class="ing-qty w-20 rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2 border">
                        <input type="text" list="unit-options" placeholder="Unit" value="${unit}" class="ing-unit w-24 rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2 border">
                        <input type="text" placeholder="Ingredient Name" value="${name}" class="ing-name flex-grow rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2 border">
                        <button type="button" class="text-gray-400 hover:text-red-500 p-2 focus:outline-none">
                            <svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                            </svg>
                        </button>
                    `;

                    // Delete handler
                    row.querySelector('button').addEventListener('click', () => {
                        row.remove();
                        syncIngredientsToHidden();
                    });

                    // Input change handler to sync
                    row.querySelectorAll('input').forEach(input => {
                        input.addEventListener('input', syncIngredientsToHidden);
                    });

                    return row;
                }

                function syncIngredientsToHidden() {
                    const rows = ingredientsContainer.querySelectorAll('div.flex');
                    const lines = [];
                    rows.forEach(row => {
                        const q = row.querySelector('.ing-qty').value.trim();
                        const u = row.querySelector('.ing-unit').value.trim();
                        const n = row.querySelector('.ing-name').value.trim();

                        if (n) { // Only add if name is present
                            let line = '';
                            if (q) line += q + ' ';
                            if (u) line += u + ' ';
                            line += n;
                            lines.push(line);
                        }
                    });
                    ingredientsHiddenInput.value = lines.join('\n');
                }

                // Initial parse from hidden input (server rendered)
                const initialText = ingredientsHiddenInput.value;
                if (initialText.trim()) {
                    initialText.split('\n').forEach(line => {
                        line = line.trim();
                        if (!line) return;

                        // Simple heuristic parse for display: 
                        // attempt to split headers "1 cup Flour" -> q=1, u=cup, n=Flour
                        // This mirrors simple parsing logic or just puts whole thing in name if complex
                        // For now, let's just dump it all in name if we can't easily split, or try a regex.
                        // Actually, since we want to populate the fields, let's try a best-effort split.

                        // Regex: Start with optional number/fraction, optional unit, then rest is name
                        // This matches the regex used in some backend parsers but simplified for JS
                        const match = line.match(/^([\d\/\.\-\s]+)?\s*(?:(cup|cups|tbsp|tsp|oz|lb|g|kg|ml|l|pinch|dash|clove|slice|can|tablespoon|teaspoon)[s]?\.?\s+)?(.*)$/i);

                        if (match) {
                            // Correctly extracted from regex
                            const q = match[1] ? match[1].trim() : '';
                            const u = match[2] ? match[2].trim() : '';
                            const n = match[3] ? match[3].trim() : '';
                            ingredientsContainer.appendChild(createIngredientRow(q, u, n));
                        } else {
                            // Fallback to simple split logic if regex fails
                            const parts = line.split(/\s+/);
                            // ... simple fallback logic ...
                            let qty = '';
                            let unit = '';
                            let name = '';
                            let idx = 0;

                            if (parts[idx] && /^[\d\/\.\-]+$/.test(parts[idx])) {
                                qty = parts[idx];
                                idx++;
                            }
                            const commonUnits = ['cup', 'cups', 'tbsp', 'tsp', 'oz', 'lb', 'g', 'kg', 'ml', 'l', 'pinch', 'clove', 'can', 'slice'];
                            if (parts[idx] && commonUnits.some(cu => parts[idx].toLowerCase().startsWith(cu))) {
                                unit = parts[idx];
                                idx++;
                            }
                            name = parts.slice(idx).join(' ');
                            ingredientsContainer.appendChild(createIngredientRow(qty, unit, name));
                        }

                    });
                } else {
                    // Start with 6 empty rows for convenience
                    for (let i = 0; i < 6; i++) {
                        ingredientsContainer.appendChild(createIngredientRow());
                    }
                }

                addIngredientBtn.addEventListener('click', () => {
                    ingredientsContainer.appendChild(createIngredientRow());
                });


                // Auto-fill logic
                const autoFillBtn = document.getElementById('auto-fill-btn');
                const urlInput = document.getElementById('url');
                const titleInput = document.getElementById('title');
                const overviewInput = document.getElementById('overview');
                // instructionsInput and importStatus are defined below in the original code, but we need them here or inside the listener
                // We will rely on existing variable names if they are in scope, or re-select.
                const instructionsInput = document.getElementById('instructions');
                const importStatus = document.getElementById('import-status');

                autoFillBtn.addEventListener('click', async () => {
                    const url = urlInput.value.trim();
                    if (!url) {
                        alert('Please enter a URL first.');
                        return;
                    }

                    autoFillBtn.disabled = true;
                    importStatus.textContent = 'Fetching and parsing recipe...';
                    importStatus.classList.remove('hidden', 'text-red-600', 'text-green-600');
                    importStatus.classList.add('text-gray-500');

                    try {
                        const response = await fetch('/recipes/import', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ url }),
                        });

                        if (!response.ok) {
                            const errorText = await response.text();
                            throw new Error(`Import failed: ${response.status} ${response.statusText} - ${errorText}`);
                        }

                        const data = await response.json();

                        if (data.title) titleInput.value = data.title;
                        if (data.overview) overviewInput.value = data.overview;

                        if (data.ingredients && data.ingredients.length > 0) {
                            // Clear existing
                            ingredientsContainer.innerHTML = '';
                            data.ingredients.forEach(ing => {
                                // Provide default empty string if null
                                const q = ing.quantity || '';
                                const u = ing.unit || '';
                                const n = ing.name || '';
                                ingredientsContainer.appendChild(createIngredientRow(q, u, n));
                            });
                            syncIngredientsToHidden();
                        }

                        if (data.instructions && data.instructions.length > 0) {
                            instructionsInput.value = data.instructions.join('\n\n');
                        }

                        importStatus.textContent = 'Import successful!';
                        importStatus.classList.remove('text-gray-500');
                        importStatus.classList.add('text-green-600');

                    } catch (error) {
                        console.error('Import error:', error);
                        importStatus.textContent = `Error: ${error.message}`;
                        importStatus.classList.remove('text-gray-500');
                        importStatus.classList.add('text-red-600');
                    } finally {
                        autoFillBtn.disabled = false;
                    }
                });
            });
        </script>

        <div class="flex justify-end space-x-3">
            <a href="{% if is_edit %}/recipes/{{ recipe.as_ref().unwrap().id }}{% else %}/{% endif %}"
                class="bg-gray-200 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-300">Cancel</a>
            <button type="submit"
                class="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700">Save</button>
        </div>
    </form>
</div>
{% endblock %}